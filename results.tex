\subsection{Results}
By using the approach described in the previous section, the new mapper grew capable of providing critical features for medical and scientific computing. This section describes each of these features in sufficient detail in the following text.

\newcommand{\ignore}[1]{}

\subsubsection{Stochastic Jittering}
Because ray-casting effectively samples a discrete signal (voxel values along the ray trajectory), the distance between those sampling points heavily influences how accurately the volume data is represented.  Due to well established limitations described by the sampling theorem, low sampling rates may result in aliasing effects 
often referred to as wood-grain artifacts in the context of volume rendering \ignore{\cite{RTVG_jittering}}. Reducing the distance between samples neutralizes these artifacts but takes an important toll on performance.


The mapper supports stochastic jittering, which is an alternative technique to counteract wood-grain artifacts by adding a random offset to the rays in the viewing direction thereby breaking the coherence between neighboring fragments which causes the aliased patterns become apparent (Figure~\ref{fig:jittering}).  Jittering is implemented by creating a random noise texture (using \texttt{vtkPerlinNoise}) and applying the offset to the ray's starting point, thus has a much lower performance penalty than reducing the sampling distance.

%\begin{figure}
%\centering
%\includegraphics[width=2.5in]{Jittering.png}
%\caption{Figure . Left: A sample rendering exhibiting wood-grain artifacts. Right: The same rendering with stochastic jittering on.}
%\label{fig:jittering}
%\end{figure}

\subsubsection{Clipping}
A set of infinite planes can be defined to clip the volume to reveal inner detail, as shown in Figure 4.  Clipping is implemented by determining the visibility of each sample along the ray according to whether that location is excluded by the clipping planes.A set of infinite clipping planes can be defined to clip the volume to reveal inner detail, as shown in Figure 4.  Clipping is implemented by determining the visibility of each sample along the ray according to whether that location is excluded by the clipping planes.

\subsubsection{Cropping}
Cropping refers to 27 regions that defined by two planes along each coordinate axis of the volume and can be independently turned on (visible) or off (invisible) to produce a variety of different cropping effects, as shown in Figure~\ref{fig:cropping}. Cropping is implemented by determining the cropping region of each sample location along the ray and including only those samples that fall within a visible region.

\begin{figure}
\centering
\includegraphics[width=2.5in]{SphereCropping.png}
\caption{Figure 3. A sphere is cropped using two different configurations of cropping regions.}
\label{fig:cropping}
\end{figure}

\subsubsection{Wide Support of Data Types} 
The vtkGPURayCastMapper supports most data types such as short, int, float, and double and both point and cell data types. Bias are scale are computed and applied to the scalars in the fragment shader to normalize the scalars between 0-1 range. 

\begin{figure}
\centering
\includegraphics[width=2.5in]{HeadClippingOblique.png}
\caption{Figure 4. Top: An example of an oblique clipping plane. Bottom: A pair of parallel clipping planes clip the volume, rendered without (left) and with (right) shading.}
\label{fig:clipping}
\end{figure}

\subsubsection{Blending Modes}
The mapper supports composite blending, minimum intensity projection, maximum
intensity projection, additive intensity and average intensity blending. Each of
these blending modes are useful for a particular use-case in medical computing.
The most common one which is also the default is the composite blending mode.
See Figure~\ref{fig:blendingmodes} for an example of the different blend modes
on the same data.

\begin{figure}[htbp]
  \centering
  \begin{subfigure}{.5\columnwidth}
    \includegraphics[width=\columnwidth]{TorsoBlendingComposite.png}
    \caption{Composite}
    \label{fig:blendcomposite}
  \end{subfigure}%
  \begin{subfigure}{.5\columnwidth}
    \includegraphics[width=\columnwidth]{TorsoBlendingMIP.png}
    \caption{Maximum Intensity}
    \label{fig:blendmax}
  \end{subfigure}
  \begin{subfigure}{.5\columnwidth}   
    \includegraphics[width=\columnwidth]{TorsoBlendingAdditive.png}
    \caption{Additive}
    \label{fig:blendadditive}
  \end{subfigure}%
  \begin{subfigure}{.5\columnwidth}
    \includegraphics[width=\columnwidth]{TorsoBlendingAverage.png}
    \caption{Average Intensity}
    \label{fig:blendaverage}
  \end{subfigure}
  \caption{Blend modes supported by the \texttt{vtkGPUVolumeRayCastMapper}}
  \label{fig:blendingmodes}
\end{figure}

\subsubsection{Masking}
Both binary and label masks are supported. With binary masks, the value in the masking volume indicates visibility of the voxel in the data volume. When a label map is in use, the value in the label map is used to select different rendering parameters for that sample.  See Figure 5 for an example of label data masks.

\subsubsection{Opacity Modulated by Gradient Magnitude}
A transfer function mapping the magnitude of the gradient to an opacity modulation value can be used to essentially perform edge detection (de-emphasize homogenous regions) during rendering. See ~\ref{fig:gradient} for an example of rendering with and without the use of a gradient opacity transfer function.

\begin{figure}[ht]
  \centering
   \begin{subfigure}[b]{0.5\columnwidth}
     \includegraphics[width=\columnwidth]{TorsoNoGradient.png}
     \caption{Without gradient opacity function}
     \label{fig:Ng1} 
   \end{subfigure}%
  \begin{subfigure}[b]{0.5\columnwidth}
    \includegraphics[width=\columnwidth]{TorsoGradient.png}
    \caption{With gradient opacity function}
    \label{fig:Ng2}
  \end{subfigure}
  \caption{Gradient magnitude based opacity modulation}
  \label{fig:gradient}
\end{figure}
